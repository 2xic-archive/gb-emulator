
class generateRam():
	def __init__(self, orgianlSize=0x10000):
		self.space = [0] * orgianlSize
	def setByte(self, address, value):
		self.space[address] = value
		return self.space[address]
	def getByte(self, address):
		return self.space[address]

class generateVoid():
	def setByte(self, address, value):
		if (address < 0 or address > 0xffff):
			raise Exception("BUG")
#		print("Wrote to void...")
#		pass
	def getByte(self, address):
		if (address < 0 or address > 0xffff):
			raise Exception("BUG")
#		pass
#		print("reading void ....")
		return 0xff

class bootrom():
	def __init__(self):
		self.space =  	[
            0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
            0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
            0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
            0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
            0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
            0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
            0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
            0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
            0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
            0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
            0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
            0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
            0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
            0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
            0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x00, 0x00, 0x23, 0x7D, 0xFE, 0x34, 0x20,
            0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x00, 0x00, 0x3E, 0x01, 0xE0, 0x50
						]
		self.offset = 0
		self.custom = False

	def setByte(self, address, value):

		if self.custom:
			return 
		import sys,os
		try:
			if not self.custom:
				print("cant write to bootom")
			else:
				print("cant write to cartridge rom...")
			print("Trying to acess memory addres... {}".format(hex(address)))
			print("")
			raise Exception("Can't write to bootom")
		except Exception as e:
			exc_type, exc_obj, exc_tb = sys.exc_info()
			fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
			print(exc_type, fname, exc_tb.tb_lineno)
			import inspect
			curframe = inspect.currentframe()
			calframe = inspect.getouterframes(curframe, 2)
			print('caller name:', calframe[1][3])
			print('caller name:', calframe[2])
			print('caller name:', calframe[3])
			print('caller name:', calframe[4])

	#	else:
	#		self.space[address] = value
		
	def loadCustom(self, space, offset):
		self.space = space
		self.offset = offset


	def getByte(self, address):
		if(self.offset > address):
			raise Exception("huh ? Bad memory self.offset")
#		print("{}	{}".format(address, self.offset))
		position = address - self.offset
		if(position >= len(self.space)):
			raise Exception("Grr overwrite message")
		return self.space[position]




class Mmu():
	def __init__(self, gui, impManger, controller, serialconnection):
		import sys
		import gpu
		import timer
		import dma
		sys.path.append('./gpu/')

		self.bootRom = bootrom()
		self.rom = bootrom()
		
		self.joypad = controller

		#	HUH ? cleaning ;=)
		self.ram = generateRam()
		self.shadowRam = generateRam()
		self.void = generateVoid()
		self.ffram = generateRam()


		self.dma = dma.dma(self)

		self.timer = timer.Timer(impManger)


	#	self.guiconnection = gui

		self.imp = impManger
		self.gpu = gpu.gpu(self.ram, gui, self.imp)
		self.opcodeid = None

		
		self.serial = serialconnection
			

		self.dmgBoostrap = 0
		
	def setByte(self, address, value):
		if(address == 0xff50):
			self.dmgBoostrap = value
		else:
			return self.getSpace(address).setByte(address, value)

	def getByte(self, address, check=False):
		if(check):
			if not self.getSpace(address) == self.bootRom:
				return self.ram == self.getSpace(address)
			else:
				return True

		if(address == 0xff50):
			return self.dmgBoostrap
		else:
			return self.getSpace(address).getByte(address)

	def getSpace(self, address):
		if (address < 0 or address > 0xffff):
			raise Exception("out of bounds memory read")

		if(self.dmgBoostrap == 0 and address >= 0x0000 and address < 0x0100):
			return self.bootRom		
		elif(address >= 0xe000 and address < (0xe000 + 0x1e00)):
			return self.shadowRam
		elif(address >= 0xff80 and address < (0xff80 + 0x0080)):
			return self.ffram
		elif(address == 0xff00):
			return self.joypad

		elif(address == 0xff50):
			return self.dmgBoostrap

		elif(address >= 0xff04 and address <= 0xff07):
			return self.timer

		elif(address >= 0xc000 and address < (0xc000 + 0x2000)):
			return self.ram

		elif(address >= 0xa000 and address < 0xc000):
			return self.rom.cartRidgeRam		
		elif(address == 0xff46):
			return self.dma
		elif(self.gpu.validadress(address)):
			return self.gpu
		elif(address == 0xff0f or address == 0xffff):
			return self.imp	
		
		elif( (address >= 0x0000 and address < 0x8000) or
			  (address >= 0xa000 and address < 0xc000) ):
			return self.rom
		else:
			return self.void
